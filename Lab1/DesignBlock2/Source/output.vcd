$date
	Mon Oct 07 13:46:07 2019
$end
$version
	Icarus Verilog
$end
$timescale
	100ps
$end
$scope module Design2_top $end
$var wire 2 ! KEY [1:0] $end
$var wire 8 " SW [7:0] $end
$var wire 4 # sum [3:0] $end
$var wire 1 $ carryout $end
$var wire 1 % carry3 $end
$var wire 1 & carry2 $end
$var wire 1 ' carry1 $end
$var wire 8 ( HEX5 [7:0] $end
$var wire 8 ) HEX4 [7:0] $end
$var wire 8 * HEX3 [7:0] $end
$var wire 8 + HEX2 [7:0] $end
$var wire 8 , HEX1 [7:0] $end
$var wire 8 - HEX0 [7:0] $end
$var reg 8 . LEDR [7:0] $end
$var reg 1 / carryin $end
$var reg 4 0 input1 [3:0] $end
$var reg 4 1 input2 [3:0] $end
$var reg 4 2 input3 [3:0] $end
$var reg 1 3 overflow $end
$scope module U0 $end
$var wire 1 / carryin $end
$var wire 1 ' carryout $end
$var wire 1 4 input1 $end
$var wire 1 5 input2 $end
$var wire 1 6 sum $end
$var wire 1 7 w1 $end
$var wire 1 8 w2 $end
$var wire 1 9 w3 $end
$upscope $end
$scope module U1 $end
$var wire 1 ' carryin $end
$var wire 1 & carryout $end
$var wire 1 : input1 $end
$var wire 1 ; input2 $end
$var wire 1 < sum $end
$var wire 1 = w1 $end
$var wire 1 > w2 $end
$var wire 1 ? w3 $end
$upscope $end
$scope module U2 $end
$var wire 1 & carryin $end
$var wire 1 % carryout $end
$var wire 1 @ input1 $end
$var wire 1 A input2 $end
$var wire 1 B sum $end
$var wire 1 C w1 $end
$var wire 1 D w2 $end
$var wire 1 E w3 $end
$upscope $end
$scope module U3 $end
$var wire 1 % carryin $end
$var wire 1 $ carryout $end
$var wire 1 F input1 $end
$var wire 1 G input2 $end
$var wire 1 H sum $end
$var wire 1 I w1 $end
$var wire 1 J w2 $end
$var wire 1 K w3 $end
$upscope $end
$scope module U4 $end
$var wire 4 L input1 [3:0] $end
$var wire 4 M input2 [3:0] $end
$var wire 1 3 overflow $end
$var wire 4 N sum [3:0] $end
$var wire 8 O HEX5 [7:0] $end
$var wire 8 P HEX4 [7:0] $end
$var wire 8 Q HEX3 [7:0] $end
$var wire 8 R HEX2 [7:0] $end
$var wire 8 S HEX1 [7:0] $end
$var wire 8 T HEX0 [7:0] $end
$var reg 4 U state [3:0] $end
$var reg 4 V val0 [3:0] $end
$var reg 4 W val1 [3:0] $end
$var reg 4 X val2 [3:0] $end
$var reg 4 Y val3 [3:0] $end
$var reg 4 Z val4 [3:0] $end
$var reg 4 [ val5 [3:0] $end
$var reg 4 \ var [3:0] $end
$var reg 4 ] vars [3:0] $end
$scope module a0 $end
$var wire 4 ^ data [3:0] $end
$var wire 4 _ data2 [3:0] $end
$var reg 8 ` display [7:0] $end
$upscope $end
$scope module a1 $end
$var wire 4 a data [3:0] $end
$var wire 4 b data2 [3:0] $end
$var reg 8 c display [7:0] $end
$upscope $end
$scope module a2 $end
$var wire 4 d data [3:0] $end
$var wire 4 e data2 [3:0] $end
$var reg 8 f display [7:0] $end
$upscope $end
$scope module a3 $end
$var wire 4 g data [3:0] $end
$var wire 4 h data2 [3:0] $end
$var reg 8 i display [7:0] $end
$upscope $end
$scope module a4 $end
$var wire 4 j data [3:0] $end
$var wire 4 k data2 [3:0] $end
$var reg 8 l display [7:0] $end
$upscope $end
$scope module a5 $end
$var wire 4 m data [3:0] $end
$var wire 4 n data2 [3:0] $end
$var reg 8 o display [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$scope module tb2 $end
$var wire 4 p sum [3:0] $end
$var wire 1 q carryout $end
$var wire 8 r HEX5 [7:0] $end
$var wire 8 s HEX4 [7:0] $end
$var wire 8 t HEX3 [7:0] $end
$var wire 8 u HEX2 [7:0] $end
$var wire 8 v HEX1 [7:0] $end
$var wire 8 w HEX0 [7:0] $end
$var reg 2 x KEY [1:0] $end
$var reg 8 y LEDR [7:0] $end
$var reg 8 z SW [7:0] $end
$var reg 1 { carryin $end
$var reg 4 | input1 [3:0] $end
$var reg 4 } input2 [3:0] $end
$var reg 4 ~ input3 [3:0] $end
$var reg 1 !" overflow $end
$scope module fullAdder_inst $end
$var wire 1 { carryin $end
$var wire 1 q carryout $end
$var wire 1 "" input1 $end
$var wire 1 #" input2 $end
$var wire 1 $" sum $end
$var wire 1 %" w1 $end
$var wire 1 &" w2 $end
$var wire 1 '" w3 $end
$upscope $end
$scope module sevensegcall2_inst $end
$var wire 4 (" input1 [3:0] $end
$var wire 4 )" input2 [3:0] $end
$var wire 1 !" overflow $end
$var wire 4 *" sum [3:0] $end
$var wire 8 +" HEX5 [7:0] $end
$var wire 8 ," HEX4 [7:0] $end
$var wire 8 -" HEX3 [7:0] $end
$var wire 8 ." HEX2 [7:0] $end
$var wire 8 /" HEX1 [7:0] $end
$var wire 8 0" HEX0 [7:0] $end
$var reg 4 1" state [3:0] $end
$var reg 4 2" val0 [3:0] $end
$var reg 4 3" val1 [3:0] $end
$var reg 4 4" val2 [3:0] $end
$var reg 4 5" val3 [3:0] $end
$var reg 4 6" val4 [3:0] $end
$var reg 4 7" val5 [3:0] $end
$var reg 4 8" var [3:0] $end
$var reg 4 9" vars [3:0] $end
$scope module a0 $end
$var wire 4 :" data [3:0] $end
$var wire 4 ;" data2 [3:0] $end
$var reg 8 <" display [7:0] $end
$upscope $end
$scope module a1 $end
$var wire 4 =" data [3:0] $end
$var wire 4 >" data2 [3:0] $end
$var reg 8 ?" display [7:0] $end
$upscope $end
$scope module a2 $end
$var wire 4 @" data [3:0] $end
$var wire 4 A" data2 [3:0] $end
$var reg 8 B" display [7:0] $end
$upscope $end
$scope module a3 $end
$var wire 4 C" data [3:0] $end
$var wire 4 D" data2 [3:0] $end
$var reg 8 E" display [7:0] $end
$upscope $end
$scope module a4 $end
$var wire 4 F" data [3:0] $end
$var wire 4 G" data2 [3:0] $end
$var reg 8 H" display [7:0] $end
$upscope $end
$scope module a5 $end
$var wire 4 I" data [3:0] $end
$var wire 4 J" data2 [3:0] $end
$var reg 8 K" display [7:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx K"
bx J"
bx I"
bx H"
bx G"
bx F"
bx E"
bx D"
bx C"
bx B"
bx A"
bx @"
bx ?"
bx >"
bx ="
bx <"
bx ;"
bx :"
bx 9"
bx 8"
bx 7"
bx 6"
bx 5"
bx 4"
bx 3"
bx 2"
bx 1"
bx 0"
bx /"
bx ."
bx -"
bx ,"
bx +"
b0x *"
bx )"
bx ("
x'"
x&"
x%"
x$"
x#"
x""
x!"
bx ~
bx }
bx |
x{
b100100 z
bx y
bx x
bx w
bx v
bx u
bx t
bx s
bx r
xq
b0x p
bx o
bx n
bx m
bx l
bx k
bx j
bx i
bx h
bx g
bx f
bx e
bx d
bx c
bx b
bx a
bx `
bx _
bx ^
bx ]
bx \
bx [
bx Z
bx Y
bx X
bx W
bx V
bx U
bx T
bx S
bx R
bx Q
bx P
bx O
bx N
bz M
bz L
xK
xJ
xI
xH
xG
zF
xE
xD
xC
xB
xA
z@
x?
x>
x=
x<
x;
z:
x9
x8
x7
x6
x5
z4
03
bz 2
bx 1
bz 0
x/
b10001000 .
bx -
bx ,
bx +
bx *
bx )
bx (
x'
x&
x%
x$
bx #
bz "
bz !
$end
#600
bx1 x
#1300
b100010 z
#2000
b10100010 z
#2700
b11111111 z
#3400
b100111 z
#4100
b11111 z
#4800
b100001 z
#5600
b11100001 z
#6400
b11101111 z
#7200
b10000111 z
#8000
